<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
    <title>Transperfect</title>
    <link rel="stylesheet" href="../css/transperfectStyles.css">
    {{!-- <link rel="stylesheet" type="text/css" href="/css/styles.css"> --}}
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.3.0/font/bootstrap-icons.css">
    <link href="https://vjs.zencdn.net/7.11.4/video-js.css" rel="stylesheet" />
    <link rel="stylesheet" href="//unpkg.com/videojs-wavesurfer/dist/css/videojs.wavesurfer.min.css"> 
    <link href="./node_modules/bootstrap-icons/font/bootstrap-icons.css">

    <script src="https://code.jquery.com/jquery-3.4.1.js"></script>
    <script src="https://vjs.zencdn.net/7.11.4/video.min.js"></script>
    <script src="//unpkg.com/videojs-wavesurfer/dist/videojs.wavesurfer.min.js"></script>

    <script src="local_modules/wavesurfer.js/dist/wavesurfer.js"></script>
    <script src="local_modules/wavesurfer.js/dist/plugin/wavesurfer.timeline.js"></script>
    <script src="local_modules/wavesurfer.js/dist/plugin/wavesurfer.regions.js"></script>
    <script src="https://unpkg.com/wavesurfer.js/dist/plugin/wavesurfer.markers.js"></script>
    
    <script src="public/js/resize.js"></script>  
    <script src="public/js/create-top-speaker-div.js"></script>
    <script src="public/js/repeat-region.js"></script>
    <script src="public/js/loadingScreen.js"></script>
    <script src="public/js/create-transperfect-divs.js"></script>
    
    {{!-- Common Scripts --}}
    <script src="public/js/common/keyDownEvents.js"></script>
    <script src="public/js/common/canvasDrawing.js"></script>
    <script src="public/js/common/commonFunctions.js"></script>
    <script src="public/js/common/transperfectCommonFunctions.js"></script>   
    <script src="public/js/common/onClickOnChangeEvents.js"></script>    
    
</head>
<body>
  <div id="transperfect-body">    
        {{>transperfectHeader}}
    
    {{>transperfectBody}}
  </div>
  

<div id="annotation-box">

  <form class="form-inline">  

        
    <div class="annotation-box-row">
      <div class="form-labels-div">
              <label class="form-inputs-labels" for="latency">*Latency</label>
      </div>
      <div class="form-input-div">
        <input type="text" class="form-inputs" id="annotation-latency" onchange="updateSegmentonTimeChange()" value="0" name="latency" disabled><br>
      </div>
    </div>
      <div class="annotation-box-row">
        <div class="form-labels-div">
          <label class="form-inputs-labels" for="actualText">*Wake Up Word</label>
        </div>
        <div class="form-input-div">
          <input id="transcription-area" class="form-inputs" onchange="updateSegmentonTimeChange()" name="actualText" value='{{wakeWord}}' style="font-size:12px;margin-left:auto">
        </div>
      </div>      

      {{!-- <div class="annotation-box-row">
        <div class="form-labels-div">
          <label class="form-inputs-labels" for="dateOfDelivery">Date of Delivery</label>
        </div>
        <div class="form-input-div">
          <input id="date-of-delivery" style="width: 140px; border-radius:5%" onchange="updateSegmentonTimeChange()" type="date" class="form-inputs" name="dateOfDelivery">
        </div>
      </div>       --}}

      <div class="annotation-box-textarea-row">
      <div class="form-textarea-div">
        <label class="form-inputs-labels" for="command">*Command</label>
      </div>
      <div >
        <textarea type="text" class="text-areas form-inputs disable-all-on-Submit" id="command" onchange="updateSegmentonTimeChange()" rows="4" placeholder="Command" name="command" value=''></textarea>
      </div>        
    </div>
    <hr class="solid-dash-line">

    {{!-- Utterance Display toggle div started --}}
    <div id="utterance-div">

    <div class="annotation-box-row">
      <div class="form-labels-div">
        <span class="labels-prefixes">;</span>
        <label class="form-inputs-labels" for="segmentStart">Segment Start</label> 
        {{!-- Segment start --}}
      </div>
      <div class="form-input-div">
        <span class="form-time-inputs">
                <input id="annotation-start-minute" class="annotation-time-class disable-all-on-Submit" type="number" min="0"
                max="59" onclick="" onchange="updateSegmentonTimeChange()" value="00"> 
                :
                <input id="annotation-start-seconds" class="annotation-time-class disable-all-on-Submit" type="number" min="0"
                    max="59" oninput="" onchange="updateSegmentonTimeChange()" value="00"> 
                .
                <input id="annotation-start-milliseconds" class="annotation-time-ms-class disable-all-on-Submit" type="number"
                    min="0" max="999" oninput="" onchange="updateSegmentonTimeChange()" value="000"> 
            </span>
            </div>
        </div>

             <div class="annotation-box-row">
              <div class="form-labels-div">
                <span class="labels-prefixes">'</span>
              <label class="form-inputs-labels" for="segmentEnd">Segment End</label>
                    </div>
                    <div class="form-input-div">
                      <span class="form-time-inputs">
                              <input id="annotation-end-minute" class="annotation-time-class disable-all-on-Submit" type="number" min="0"
                              max="59" onclick="" onchange="updateSegmentonTimeChange()" value="00"> 
                              :
                              <input id="annotation-end-seconds" class="annotation-time-class disable-all-on-Submit" type="number" min="0"
                                  max="59" oninput="" onchange="updateSegmentonTimeChange()" value="00"> 
                              .
                              <input id="annotation-end-milliseconds" class="annotation-time-ms-class disable-all-on-Submit" type="number"
                                  min="0" max="999" oninput="" onchange="updateSegmentonTimeChange()" value="000"> 
                      </span>
                    </div>

        </div>

        <div class="annotation-box-row" style="">
        <div class="form-labels-div">
          <span class="labels-prefixes" style="background-color: #ff990a;">[</span>
            <label class="form-inputs-labels" for="wakeWordStart">Wake Word Start</label>
        </div>
        <div class="form-input-div">          
            <span class="form-time-inputs">
                  <input id="wake-word-start-minute" class="annotation-time-class disable-all-on-Submit" type="number" min="0"
                  max="59" onclick="" onchange="updateSegmentonTimeChange()" value="00">
                  :
                  <input id="wake-word-start-seconds" class="annotation-time-class disable-all-on-Submit" type="number" min="0"
                      max="59" oninput="" onchange="updateSegmentonTimeChange()" value="00"> 
                  .
                  <input id="wake-word-start-milliseconds" class="annotation-time-ms-class disable-all-on-Submit" type="number"
                      min="0" max="999" oninput="" onchange="updateSegmentonTimeChange()" value="000">
            </span>
        </div>
      </div>

            

  <div class="annotation-box-row">
        <div class="form-labels-div">
          <span class="labels-prefixes" style="background-color: #00ffcc;">]</span>
            <label class="form-inputs-labels" for="wakeWordStart">Wake Word End</label>
        </div>
        <div class="form-input-div">
          <span class="form-time-inputs">
                  <input id="wake-word-end-minute" class="annotation-time-class disable-all-on-Submit" type="number" min="0"
                  max="59" onclick="" onchange="updateSegmentonTimeChange()" value="00">
                  :
                  <input id="wake-word-end-seconds" class="annotation-time-class disable-all-on-Submit" type="number" min="0"
                      max="59" oninput="" onchange="updateSegmentonTimeChange()" value="00"> 
                  .
                  <input id="wake-word-end-milliseconds" class="annotation-time-ms-class disable-all-on-Submit" type="number"
                      min="0" max="999" oninput="" onchange="updateSegmentonTimeChange()" value="000">
            </span>
        </div>
      </div>  
   
      
 


      <div class="annotation-box-row">
        <div class="form-labels-div">
          <span class="labels-prefixes" style="background-color: #eb4034;">,</span>
          <label class="form-inputs-labels" for="commandStart">Command Start</label>
        </div>
        <div class="form-input-div">
          <span class="form-time-inputs">
                <input id="command-start-minute" class="annotation-time-class disable-all-on-Submit" type="number" min="0"
                max="59" onclick="" onchange="updateSegmentonTimeChange()" value="00"> 
                :
                <input id="command-start-seconds" class="annotation-time-class disable-all-on-Submit" type="number" min="0"
                    max="59" oninput="" onchange="updateSegmentonTimeChange()" value="00"> 
                .
                <input id="command-start-milliseconds" class="annotation-time-ms-class disable-all-on-Submit" type="number"
                    min="0" max="999" oninput="" onchange="updateSegmentonTimeChange()" value="000"> 
            </span>
        </div>
      </div>    

      <div class="annotation-box-row">
        <div class="form-labels-div">
          <span class="labels-prefixes">.</span>
          <label class="form-inputs-labels" for="startOfAssistant">Start of Assistant</label>
        </div>
        <div class="form-input-div">
          <span class="form-time-inputs">
                <input id="start-of-assistant-minute" class="annotation-time-class disable-all-on-Submit" type="number" min="0"
                max="59" onclick="" onchange="updateSegmentonTimeChange()" value="00"> 
                :
                <input id="start-of-assistant-seconds" class="annotation-time-class disable-all-on-Submit" type="number" min="0"
                    max="59" oninput="" onchange="updateSegmentonTimeChange()" value="00"> 
                .
                <input id="start-of-assistant-milliseconds" class="annotation-time-ms-class disable-all-on-Submit" type="number"
                    min="0" max="999" oninput="" onchange="updateSegmentonTimeChange()" value="000"> 
            </span>
        </div>
      </div>    
    </div>
    {{!-- Utterance toggle div end --}}
  </form>   
  <hr style="opacity: 0.5;">
  <div class="annotation-footer">
    <div>
      {{!-- <button id="annotation-split" class="disable-all-on-Submit"
        style="margin:5px 10px 20px 0px;color:black; border:none;background: none;font-size: 18px;">SPLIT</button> --}}
        <button id="close" class="disable-all-on-Submit"
        style="padding:8px; color:white; border:none;background: red;font-size: 14px; cursor:pointer;border-radius:10%">CANCEL</button>    
    </div>
    <div style="align-items: center; display: flex;">
        <button id="annotation-remove" class="disable-all-on-Submit"
        style="padding:8px; color:white; border:none;background: red;font-size: 14px; cursor:pointer;border-radius:10%">REMOVE</button>    
        <button id="annotation-save" class="disable-all-on-Submit"
        style="padding:8px; margin:0px 20px 0px 20px;color:white; border-radius:4px;border:none;background:#007bff;font-size: 14px;cursor: pointer;border-radius:10%">SAVE</button>
    </div>
    
  </div>
  
</div><!-- Ending tag for Annotation Box -->
    

    <script>
        var user_id;
        var audio_id;
        audio_id = {{ audio_id }};
        user_id = '{{ user_id }}';

        var Wakeword='{{wakeWord}}';

        var is_submitted = "FALSE";
        var leftSpeakerCategoryDivMargin = 120;

        var actualResponseLength = 0;//Assigns total response length
        var postsResponseLength = 0;//Assigns total posts length
        var wrongSpeakerScore = 0;
        var wrongAnnotationScore = 0;
        var unnecessarySegmentsErrors = 0;
        var overallScore = 0;//var to assign score
        var passOrFail = ""//var to assign pass or fail
        var reqSpeakers = [];//var to check if speakers are already available  
        var addRegionBool = true;//Bool for adding region only one on click
        var canvasHeight = 0;
        var updateAnnotationOnClick = false;//allow updating annotation box only on click
        var updateAnnotationOnChange = false;//allow updating annotation box only on change
        var updateTopDivSpeakerOnClick = false;//allow updating only on click 
        var updateTopDivSpeaker = false;//checking top div speaker changes
        var updateSegments = true;//update segments only if not new region 
        var dragging = false;//allow dragging
        var temp, y, diff, segmentStart, segmentEnd = 0;
        var pressed = false;
        var segmentId = 1;
        var currentId = "";
        var currentStartTime, currentEndTime = 0;
        var newStartTime, newEndTime = 0;
        var confirmChangesboxBool = false;//boolean true if confirm changes box appears
        var speakerNameCheckBool = true;//true if speaker name is valid
        var hundredMillisecSegmentCheck = true;//true if segment is created above 100 ms
        var segmentEndingTimeMoreThanStartingTime = false;
        var sameSpeakerOverlapping = false;//true if two same speakers overlap each other
        var pixels = 0;
        var correctSegmentCreated = false;
        var getTopClickedId;

        var isTransperfect=true;

        var buttons = {
            play: document.getElementById("play-button")
        }

        //Video Js Options
    let videoJSOptions={
       controls: false,
       bigPlayButton: false,
      autoplay: false,
      loop: false,
      fluid: false,
      width: 300,
      height: 600,
      muted: true
    }

    // create player
    var player = videojs('myVideo', videoJSOptions, function () {
      // print version information at startup
      var msg = 'Using video.js ' + videojs.VERSION +
        ' with videojs-wavesurfer ' +
        videojs.getPluginVersion('wavesurfer') +
        ' and wavesurfer.js ' + WaveSurfer.VERSION;
      videojs.log(msg);

      // load file
      player.src({ src: 'https://audiobee-production-user-files.s3.eu-north-1.amazonaws.com/tcp_projects/Samsung_P000_2_20210602.mp4', type: 'video/mp4' });
    });

    //Creating the audio stream from Wavesurfer 
    let wavesurferOptions={
      container: '#peaks-container',
      waveColor: 'grey',
      progressColor: 'grey',
      minPxPerSec: 96,
      scrollParent: false,
      autoCenter: true,
      backgroundColor: "#fff",
      seekStyle: "line",
      mediaControls: true,
      barWidth: 1,
      barHeight: 0.5,
      height: 316,
      plugins: [
        WaveSurfer.timeline.create({
          container: "#time-line",
          timeInterval: 0.1,
          height: 50,
          notchPercentHeight: 25
        }),
        WaveSurfer.regions.create({}),
          WaveSurfer.markers.create({}),
      ]
    };

  

    var spectrum = WaveSurfer.create(wavesurferOptions);
    spectrum.zoom(96);

    displayWaveSurferLoading();

    //handle play button
    buttons.play.addEventListener("click", function (event) {
      event.preventDefault();
      playPauseSpectrum();
      document.getElementById('total-timestamp').innerText = secondsToTimestamp(spectrum.getDuration());
      document.getElementById("total-time-hour").innerText=secondsToHours(spectrum.getDuration());

    });

    //function on spectrum is ready 
    spectrum.on("ready", function () {

      totalDuration = spectrum.getDuration();

      //canvas height to set the top speaker annotation div position from left 
      canvasHeight = $("#peaks-container > wave canvas").height();

      //audio wave total height 
      $("#peaks-container").css({
        "width": `calc(${totalDuration} * 96px)`
      })
  
      $("#plus-button").css({
        "marginTop": `calc(${$('#peaks-container > wave > wave').offset().top}px - 15px)`
      })
      $("#time-line").css({
        "transform": `translate(0px,${$("wave").height() - 10}px)`
      })
      $("#annotation-div-head").css({
        "left": `${canvasHeight}px`
      })
      buttons.play.disabled = false;
      totalDuration = spectrum.getDuration();
      document.getElementById('total-timestamp').innerText = secondsToTimestamp(totalDuration); 
      document.getElementById("total-time-hour").innerText=secondsToHours(totalDuration);


      //Key Down Events
      transperfectKeyEvents(spectrum);

      //Making our canvas line visible 
      $("#peaks-container > wave").css({ "overflow": "" });      

      //Canvas Straight Line    
      canvasStraightLine();   
    });//Function end for on ready spectrum
  
    //Resize Window on ready
    $(document).ready(function(){
      resizeTransperfectScreen();
    });
    window.onload = function(e){ 
      resizeTransperfectScreen();
    }
    window.addEventListener("resize",resizeTransperfectScreen)

    //Update Time
    setInterval(updateTimer(), 100);    

    //Loading the Audio
    spectrum.load("{{audio_url}}");

    //function for dragging spectrum on mousedown
    window.onload = (function () {
      if (!confirmChangesboxBool) {
        $("#peaks-container,#top-div-for-scrolling-enabling").on("mousedown", function (e) {          
          pauseAudio();
          dragging = true;
          temp = y = e.clientY;
        })
        $("#peaks-container,#top-div-for-scrolling-enabling").on("mousemove", function (e) {

          if (dragging == true) {
            y = e.clientY;
            diff = y - temp;
            temp = y;

            var req = (spectrum.getCurrentTime() + (diff * (-1) / 96)) / spectrum.getDuration();
           
            req < 0 ? req = 0 : req = req;
            req > 1 ? req = 1 : req = req;
            spectrum.seekTo(req);

          }
        })
        $(window).on("mouseup", function (e) {
          dragging = false;
        })
      }
    })//Window.onload function end for mouse events

    //Function on scrolling to seek spectrum  
    document.getElementById("peaks-container").addEventListener("wheel", function (event) {     

      if (!confirmChangesboxBool) {
        pauseAudio();
        var req = (spectrum.getCurrentTime() + (event.deltaY / 96)) / spectrum.getDuration();
        req < 0 ? req = 0 : req = req;
        req > 1 ? req = 1 : req = req;
        spectrum.seekTo(req);
      }
    });

    document.getElementById("top-div-for-scrolling-enabling").addEventListener("wheel", function (event) {
      if (!confirmChangesboxBool) {
        pauseAudio();
        var req = (spectrum.getCurrentTime() + (event.deltaY / 96)) / spectrum.getDuration();
        req < 0 ? req = 0 : req = req;
        req > 1 ? req = 1 : req = req;
        spectrum.seekTo(req);
      }
    });
    //Scroll Function Ends

    window.addEventListener("scroll", function (event) {
      event.preventDefault();
    })

    //function on spectrum ready
    spectrum.on("ready", function () {    
              
      //Load Wave to previous time stamp from cookie
      if (getCookie("current_time") > 0) {
        spectrum.seekTo(parseFloat(getCookie("current_time")));        
      };

      //function on ctrl+quote key down and ctrl+colon
      ctrlquote();
      ctrlcolon();

      getPreviousCreatedSegments();      
    });//spectrum on ready function end

    function getPreviousCreatedSegments() {
      //ajax to create previously created segments by user on spectrum load
      $.ajax({
        method: "POST",
        url: "/get-transperfect-created-segments",
        data: {
          userId: user_id,
          audioId: audio_id
        },
        async: true,
        success: function (response) {

          
          for (var i = 0; i < response.length; i++) {            
            const {
                segmentId,                
                segmentStart,
                segmentEnd,
                wakeWord,                
                latency,
                command,
                wakeWordStart,
                wakeWordEnd,
                commandStart,
                startOfAssistant,                                                
            }=response[i];           

            //creating Segments 
            spectrum.addRegion({
              id: segmentId,
              start: segmentStart,
              end: segmentEnd,
              drag: false,
              color: "rgba(0,0,0,0)"
            })            
            //createDiv(divId,divClass,divTitle,segmentStart,segmentEnd,annotationText) 
            createTransperfectSegments(segmentId,                
                segmentStart,
                segmentEnd,                
                wakeWord,                
                latency,
                command,
                wakeWordStart,
                wakeWordEnd,
                commandStart,
                startOfAssistant
                );
          }

          //ajax to check if the user has already submitted
          $.ajax({
            method: "POST",
            url: "/get-submitted-or-not",
            data: {
              user_id: user_id,
              audio_id: audio_id
            },
            async: true,
            success: function (response) {
              if (response.length > 0) {
                is_submitted = response[0]["is_submitted"];
                //Checking if already submitted
                if (is_submitted == "TRUE") {
                  //$("#display-training-segments").show();//Display Select Tag For Correct Segments
                  //console.log("Euta log");
                  disableAllInterfaceOnSubmit();
                  ajaxReq();//Ajax Request to check correct incorrect segment
                  //displayHamburger();
                  $("#submit-button").hide();
                  $("#profile-link-button").show();
                  if(!location.hash){
                    $("#already-submitted-dialouge-box").show();
                    $("body").not("#already-submitted-dialouge-box").css({
                      backgroundColor: "#c2c1c0",
                      opacity: "0.8"
                    })
                    //Boolean to stop user from using LT
                    confirmChangesboxBool = true;
                  }
                  
                }
              }
            }
          })
        }
      })
    }

    //Remove Region             
    $("#annotation-remove").on("click", function () {
      updateSegments = true;
      var regionId = currentId;
      //ajax request to remove segments
      var params = {
        segmentId:regionId,
        userId:user_id,
        audioId: audio_id
      }
      if (regionId != null) {
        $.ajax({
          method: "POST",
          url: "/remove-transperfect-user-segments",
          data: params,
          success: function () {            
            ////console.log("Removed");
            updateAnnotationOnChange = false;
            updateAnnotationOnClick = false;
            //Changed RegionId to CurrentId
            if (spectrum.regions.list[regionId] != null) {
              spectrum.regions.list[regionId].remove();
            }
            $("#" + regionId).empty();
            $("#" + regionId).remove();
          }
        });
      }
      addRegionBool = true;
    });//Remove Region Function End

    //Remove top speaker divs
    $("#top-div-control-remove-button").on("click", function () {
      removeTopDivSpeakers(getTopClickedId);
    });
    
    //function to save all top div speakers
    $("#top-div-control-save-button").on("click", function () {
      saveTopDivSpeakers(getTopClickedId);
    });

    function saveTopDivSpeakers(topSpeakerClickedId) {
      //Getting the clicked Top Div Class
      var getClickedIdClass = document.getElementById(topSpeakerClickedId).className;
      var speakerNameFound = false;
      var userInputTopSpeakerName = $("#top-div-control-speaker-name").val();
      if (spellCheckSpeakerName(userInputTopSpeakerName,"speaker")) {
        document.getElementById(topSpeakerClickedId).className = userInputTopSpeakerName.replace(/ /g, "-");
        document.getElementById(topSpeakerClickedId).querySelector("p").innerText = userInputTopSpeakerName;
        $("#peaks-container").children().each(function (index, value) {
          if (this.className == getClickedIdClass) {
            speakerNameFound = true;
            //console.log(this.className);
            this.className = userInputTopSpeakerName.replace(/ /g, "-");
          }
        });
        if (speakerNameFound) {
          params = {
            userInputTopSpeakerName: userInputTopSpeakerName,
            previousTopSpeakerName: getClickedIdClass.replace(/-/g, " "),
            user_id,
            audio_id: audio_id
          }

          $.ajax({
            method: "POST",
            url: "/top-speaker-control-save-button",
            data: params,
            success: function (response) {
              //console.log("Top Speakers Name Updated");
              updateTopDivSpeaker = false;
              updateTopDivSpeakerOnClick = false;
            }
          })
        };
      } else {
        emptySpeaker();
      }      
    }
    //save top div speakers function end 

    //First Navigator Turn Button
    $("#top-speaker-first-navigator-button").on("click", function () {
      navigateTurnsFirstButton(getTopClickedId,spectrum);  
      player.currentTime(spectrum.getCurrentTime());    
    });   
    //first navigator function end

    //second navigator function start
    $("#top-speaker-last-navigator-button").on("click", function () {
      navigateTurnsLastButton(getTopClickedId,spectrum);
    });
    //Second Navigator Function End

    //displaying contents on audio processing
    spectrum.on("audioprocess", () => {
      if (spectrum.regions.getCurrentRegion() != null && !updateAnnotationOnChange && !updateTopDivSpeaker) {
          //Check If same segments
        let spectrumRegionId=spectrum.regions.getCurrentRegion().id;        
        
        if(currentId!=spectrum.regions.getCurrentRegion().id){        
            displayCurrentContents();
            highlightRegion();  
        }
        //currentId = spectrum.regions.getCurrentRegion().id;        
      }
    })

    //Seeking Specturm
    spectrum.on("seek", function () {
      //Displaying Current Segments Contents in our Annotation Box            
      player.currentTime(spectrum.getCurrentTime())
      if (!updateTopDivSpeaker) {
        displayCurrentContents();
      }
      //Displaying submit button only if audio is played to last and 10 segements are created    
      if ((spectrum.getCurrentTime() > (spectrum.getDuration() - 0.1)) && ($("#peaks-container").children("div").length > 10)) {
        //console.log(is_submitted);
        if (is_submitted == "FALSE") {
          $("#submit-button").show();
        }
      }else{
          $("#submit-button").hide();
      }
    });

    var colorArr=[];    

    var zindexLoop = 1000;   

    //function to check changes on top div speaker control
    function updateTopSpeakerControl() {
      updateTopDivSpeaker = true;
    }

//function for annotation contents change on click
    function changeAnnotationOnClick(evt) {
      //Displaying Annotation Div
      if (!updateTopDivSpeaker) {
        $("#top-div-speaker-control").hide();
        $("#annotation-box").show();
      }

      if (!updateAnnotationOnChange && !updateTopDivSpeaker) {
        
        var clickedId = evt.target.id;
        currentId = evt.target.id;
        //highlight clicked region
        highlightRegion();
        //Changed currentId to clicked Id to check if it works, works until now 
        currentStartTime = spectrum.regions.list[clickedId].start;
        currentEndTime = spectrum.regions.list[clickedId].end;     

        //segment start variables
        var startMinute = secondsToMinutes(spectrum.regions.list[clickedId].start);
        var startSeconds = secondsToSeconds(spectrum.regions.list[clickedId].start);
        var startMilliseconds = secondsToMilliseconds(spectrum.regions.list[clickedId].start);

        //segment end variables
        var endMinute = secondsToMinutes(spectrum.regions.list[clickedId].end);
        var endSeconds = secondsToSeconds(spectrum.regions.list[clickedId].end);
        var endMilliseconds = secondsToMilliseconds(spectrum.regions.list[clickedId].end);

        //displaying texts   
        $("#annotation-start-minute").val(startMinute);
        $("#annotation-start-seconds").val(startSeconds);
        $("#annotation-start-milliseconds").val(startMilliseconds);
        $("#annotation-end-minute").val(endMinute);
        $("#annotation-end-seconds").val(endSeconds);
        $("#annotation-end-milliseconds").val(endMilliseconds);

        
        if ($("#peaks-container").children().is("#" + clickedId) > 0) {          
          var divColor = document.getElementById(clickedId).style.background;

          //changing color of Annotation Heading
          $(".annotation-editHeading").css("backgroundColor", divColor);

          setTransperfectFields(clickedId);           

          //Add Markers after clearing previous markers
          //Wake word start marker  
          spectrum.markers.clear();              
          const wordStart=parseAnnotationTime($("#wake-word-start-minute").val(),$("#wake-word-start-seconds").val(),$("#wake-word-start-milliseconds").val());
          addMarker(spectrum,wordStart,'WS','#ff990a');

          //Wake word end marker
          const wordEnd=parseAnnotationTime($("#wake-word-end-minute").val(),$("#wake-word-end-seconds").val(),$("#wake-word-end-milliseconds").val());
          addMarker(spectrum,wordEnd,'WE','#00ffcc');

          //Command start marker
          const commandStart=parseAnnotationTime($("#command-start-minute").val(),$("#command-start-seconds").val(),$("#command-start-milliseconds").val());
          addMarker(spectrum,commandStart,'CS','#eb4034');

          //Start of assistant marker
          const assistantStart=parseAnnotationTime($("#start-of-assistant-minute").val(),$("#start-of-assistant-seconds").val(),$("#start-of-assistant-milliseconds").val());
          addMarker(spectrum,assistantStart,'SOA','#a71dbf');
        }
      }
    };

    //function to save data to database on saveClick
    function saveClick() {        
        segmentStart = spectrum.regions.list[currentId].start;
        segmentEnd = spectrum.regions.list[currentId].end;        
        var wakeUpWordStart = segmentStart 
        //parseAnnotationTime($("#wake-word-start-minute").val(),$("#wake-word-start-seconds").val(),$("#wake-word-start-milliseconds").val());
        var wakeUpWordEnd =  parseAnnotationTime($("#wake-word-end-minute").val(),$("#wake-word-end-seconds").val(),$("#wake-word-end-milliseconds").val());
        var commandStart =parseAnnotationTime($("#command-start-minute").val(),$("#command-start-seconds").val(),$("#command-start-milliseconds").val());
        var startOfAssistant=parseAnnotationTime($("#start-of-assistant-minute").val(),$("#start-of-assistant-seconds").val(),$("#start-of-assistant-milliseconds").val());        
        var wakeUpWord=$("#transcription-area").val()==""?Wakeword:$("#transcription-area").val();
        var command=$("#command").val();
        var latency = commandStart-wakeUpWordEnd;
        

        if(wakeUpWord=="" || command ==""){
          alert("All fields must be filled");
          return;
        }

        if(latency<0){
          alert("Command start time must be greater than wakeword END time!");
          return;
        }


        //ajax Request to Create    
        var params = {          
          latency,
          wakeUpWordStart,
          wakeUpWordEnd,
          commandStart,
          startOfAssistant,
          wakeUpWord,
          command,          
          segmentStart,
          segmentEnd,          
          userId:user_id,
          audioId: audio_id
        }

        console.log(params)

      if (updateSegments == false) {
        
        if ( hundredMillisecSegmentCheck && !segmentEndingTimeMoreThanStartingTime && (!checkOverlappingDiv(segmentStart, segmentEnd))) {
          
            //Var to store id from database
            var segmentIdFromDatabase = 0;

            $.ajax({
              method: "POST",
              url: "/create-transperfect-segment",
              data: params,
              async: true,
              success: function (response) {                                  
                segmentIdFromDatabase = response.segmentId;                
                $(`region[data-id=${currentId}]`).attr("data-id", segmentIdFromDatabase);
                spectrum.regions.list[currentId].id = segmentIdFromDatabase;
                spectrum.regions.list[segmentIdFromDatabase] = spectrum.regions.list[currentId];
                delete spectrum.regions.list[currentId];
                if (!updateAnnotationOnChange) {//Only if new segment is created
                  window.currentId = segmentIdFromDatabase;
                  window.segment_id = segmentIdFromDatabase;
                }
                //Create Div 
                createTransperfectSegments(
                    segmentIdFromDatabase, 
                    segmentStart, 
                    segmentEnd, 
                    wakeUpWord,
                    latency,
                    command,
                    wakeUpWordStart,
                    wakeUpWordEnd,
                    commandStart,
                    startOfAssistant,                                       
                  );
                  $("#annotation-latency").val(latency);
                  $("#transcription-area").val(wakeUpWord)
              },
                error: function (XMLHttpRequest, textStatus, errorThrown) {
                alert('Error '+errorThrown)
              }
            })
            
            updateAnnotationOnChange = false;
            updateAnnotationOnClick = false;
            

            //setting update segments bool to true to allow updating
            updateSegments = true;          
        } else {          
          if (!hundredMillisecSegmentCheck) {
            ////console.log("Less Than Hundred Milliseconds");
            hundredMillisecondsSegmentGap();
          } else if (segmentEndingTimeMoreThanStartingTime) {
            ////console.log("End Time More Than Start Time");
            endTimeMoreThanStartTime();
          } else if ((checkOverlappingDiv(segmentStart, segmentEnd))) {
            ////console.log("New Div for Overlapping");
            sameSpeakerOverlappingDialougeBox();
          }
        }
      } else if (updateAnnotationOnChange == true) {   
        
        var segmentId = currentId;        
        ////console.log(segmentclass.replace(" ", "-"));
        var val = document.getElementById("annotation-type");   
            
            $("#annotation-div").children().each(function (index, value) {
              if (value.className == "speaker") {                    
                if (!checkOverlappingDiv( newStartTime, newEndTime)) {                  
                  
                  // annotationText = $("#transcription-area").val();
                  document.getElementById(segmentId).querySelector("p").innerText = wakeUpWord+" "+command;
                  document.getElementById(segmentId).style.background = value.style.backgroundColor;                  
                  document.getElementById(segmentId).style.bottom = ((canvasHeight - 8) + leftSpeakerCategoryDivMargin * (1)) + "px";
                  
                  document.getElementById(segmentId).style.top = "inherit";

                  setDataAttributes(
                    document.getElementById(segmentId),
                    segmentStart,
                    segmentEnd,
                    wakeUpWord,
                    latency,
                    command,
                    wakeUpWordStart,
                    wakeUpWordEnd,
                    commandStart,
                    startOfAssistant,                    
                  )
                }
              }
            });
        
        //ajax Request To Update        
        if ( hundredMillisecSegmentCheck && !segmentEndingTimeMoreThanStartingTime && !checkOverlappingDiv(newStartTime, newEndTime)) {
          
          //Remove User Id and Audio Id
          delete params.userId;
          delete params.audioId;
          
          $.ajax({
            method: "POST",
            url: "/update-transperfect-segment",
            data: {...params,segmentId},
            success: function () {
              $("#annotation-latency").val(latency);
              $("#transcription-area").val(wakeUpWord);
            },
            error: function (XMLHttpRequest, textStatus, errorThrown) {
              alert('Error '+errorThrown)
            }
          })
          
          updateAnnotationOnChange = false;
          updateAnnotationOnClick = false;
          updateSegments=true;

        } else {
           if (!hundredMillisecSegmentCheck) {
            ////console.log("Less Than Hundred Milliseconds");
            hundredMillisecondsSegmentGap();
          } else if (segmentEndingTimeMoreThanStartingTime) {
            ////console.log("End Time More Than Start Time");
            endTimeMoreThanStartTime();
          } else if (checkOverlappingDiv(newStartTime, newEndTime)) {
            ////console.log("Overlapping Speakser");
            sameSpeakerOverlappingDialougeBox();
          }
        }
      }
    }

    //function for split
    function splitRegion(textBeforeCursor = "", textAfterCursor = "") {
      pauseAudio();
      var getCurrentIdForSplit=currentId;
      var spectrumCurrentTime = spectrum.getCurrentTime();
      var regionStartTime = spectrum.regions.list[currentId].start;
      var regionEndTime = spectrum.regions.list[currentId].end;
      var prevDivTitle = document.getElementById(currentId).title;
      var prevDivClassName = document.getElementById(currentId).className.replace(/-/g, " ");
      var segmentText = document.getElementById(currentId).innerText;
      var preDivColor = document.getElementById(currentId).style.background;

      //updating Previous Region on split
      if (spectrum.regions.list[currentId] != null) {
        spectrum.regions.list[currentId].update({
          start: regionStartTime,
          end: spectrumCurrentTime - 0.01
        });
      }

      //updating previous div on Split     
      var progress2 = ((spectrumCurrentTime - 0.10) - regionStartTime) / spectrum.getDuration();
      var minPxDelta = 1 / spectrum.params.pixelRatio;
      var pos1 = Math.round((progress2) * spectrum.drawer.getWidth()) * minPxDelta;
      if ($("#peaks-container").children().is("#" + currentId)) {
        document.getElementById(currentId).style.width = pos1 + "px";
      }

      

      //previous Div text 
      document.getElementById(currentId).querySelector("p").innerText = textBeforeCursor;

      

      //ajax Request to Update Previous Division 
      var updateParams = {
        segmentId: currentId,
        speakerName: prevDivClassName,
        annotationType: prevDivTitle,
        segmentStart: regionStartTime,
        segmentEnd: spectrumCurrentTime - 0.010,
        annotationText: textBeforeCursor,
        user_id,
        audio_id: audio_id
      }

      $.ajax({
        method: "POST",
        url: "/update-on-split",
        data: updateParams,
        success: function () {
          ////console.log("Updated");
        }
      })

      //ajax Request to Create new row for splitted Div 
      var params = {
        speakerName: prevDivClassName,
        annotationType: prevDivTitle,
        segmentStart: spectrumCurrentTime + 0.010,
        segmentEnd: regionEndTime,
        annotationText: textAfterCursor,
        user_id,
        audio_id: audio_id
      }

      $.ajax({
        method: "POST",
        url: "/database",
        data: params,
        success: function (response) {
          ////console.log("Success");
          //creating new Segment on Split 
          spectrum.addRegion({
            id: response.insertId,
            start: spectrumCurrentTime + 0.010,
            end: regionEndTime,
            drag: false,
            color: "rgba(0,0,0,0)"
            })
              //$(`region[data-id=${getCurrentIdForSplit}]`).attr("data-id", response.insertId);
              // spectrum.regions.list[getCurrentIdForSplit].id = response.insertId;
                //spectrum.regions.list[response.insertId] = spectrum.regions.list[getCurrentIdForSplit];
                //delete spectrum.regions.list[getCurrentIdForSplit];

                //createDiv(divId,divClass,divTitle,segmentStart,segmentEnd,annotationText) 
          createTransperfectSegments(response.insertId, prevDivClassName, prevDivTitle, spectrumCurrentTime, regionEndTime, textAfterCursor);
            if (!updateAnnotationOnChange) {//Only if new segment is created
                
                  window.currentId = response.insertId;
                  window.segment_id = response.insertId;
          //    console.log(currentId);
            }
        }
      })
    }//split Region Function end

    $("#annotation-split").on("click", function () {
      //Split test
      var firstLength = ($("#transcription-area").prop("selectionStart"));//Cursor Position in transcription-area
      var reqText = $("#transcription-area").val();
      var textBeforeCursor = reqText.substring(0, firstLength);
      var textAfterCursor = reqText.substring(firstLength, reqText.length);
      
      if(spectrum.regions.getCurrentRegion()){
        splitRegion(textBeforeCursor, textAfterCursor);
        updateAnnotationOnChange = false;
        updateAnnotationOnClick = false;
      }      
    });    
        
    //function to check and create segments
    function createSegments(currentId, starting, ending) {
      if (spectrum.regions.list[currentId] != null) {
        ////console.log("Id" + currentId);
        if ((parseFloat(ending) - parseFloat(starting)) < 0.100 && (parseFloat(ending) - parseFloat(starting)) >= 0) {
          spectrum.regions.list[currentId].update({
            start: starting,
            end: parseFloat(ending) + 0.01
          });
          hundredMillisecSegmentCheck = false;
          segmentEndingTimeMoreThanStartingTime = false;
        } else if ((parseFloat(ending) - parseFloat(starting)) < 0) {
          spectrum.regions.list[currentId].update({
            end: starting,
            start: ending
          });
          hundredMillisecSegmentCheck = true;
          segmentEndingTimeMoreThanStartingTime = true;
        } else {
          spectrum.regions.list[currentId].update({
            start: parseInt($("#annotation-start-minute").val() * 60) + parseInt($("#annotation-start-seconds").val()) + "." + $("#annotation-start-milliseconds").val(),
            end: parseInt($("#annotation-end-minute").val() * 60) + parseInt($("#annotation-end-seconds").val()) + "." + $("#annotation-end-milliseconds").val()
          });
          hundredMillisecSegmentCheck = true;
          segmentEndingTimeMoreThanStartingTime = false;
        }
      }

      //highlight clicked region
      highlightRegion();

      newStartTime = spectrum.regions.list[currentId].start;
      newEndTime = spectrum.regions.list[currentId].end;
      ////console.log(newStartTime);
      var progress1 = newStartTime / spectrum.getDuration();
      var progress2 = (newEndTime - newStartTime) / spectrum.getDuration();
      var minPxDelta = 1 / spectrum.params.pixelRatio;
      var pos = Math.round((progress1) * spectrum.drawer.getWidth()) * minPxDelta;
      var pos1 = Math.round((progress2) * spectrum.drawer.getWidth()) * minPxDelta;
      if ($("#peaks-container").children().is("#" + currentId)) {
        document.getElementById(currentId).style.left = pos + "px";
        document.getElementById(currentId).style.width = pos1 + "px";
      }
    }

    //Function to Check correct speakername
    //Different For Transperfect and Other LTs
    function spellCheckSpeakerName(speakerName,type) {      
      var splitSpeakerName = speakerName.split(" ");    
      
      if (splitSpeakerName[0] != "speaker" ) {        
        if (((type=="annotation") && (splitSpeakerName == "DTMF" || splitSpeakerName == "Applause" || splitSpeakerName == "Laughter" || splitSpeakerName == "Music" || splitSpeakerName == "Noise" || splitSpeakerName == "Ringtone")) || ((type=="speaker") && (splitSpeakerName[0] == "unidentifiable" && splitSpeakerName[1] == "speaker"))) {
          
          return true;
        } else if (splitSpeakerName[0] == "pre" && splitSpeakerName[1] == "recorded" && splitSpeakerName[2] == "speaker") {
          //Insert More Code Below if pre recorded speaker name is needed too!
          if (splitSpeakerName.length != 4) {            
            return false;
          }
          if (isNaN(splitSpeakerName[3])) {            
            return false;
          }
          return true;
        }        
        return false;
      }
      if (isNaN(splitSpeakerName[1])) {
        if (splitSpeakerName.length == 2 || splitSpeakerName.length == 3) {
          if (splitSpeakerName.length == 3) {
            if (!isCamelCase(splitSpeakerName[2])) {
              return false;
            }
          }
          if (!isCamelCase(splitSpeakerName[1])) {
            return false;
          }
        }
        else {
          return false;
        }
      } else {
        if (splitSpeakerName.length != 2) {
          return false;
        }
        if (isNaN(splitSpeakerName[1])) {
          return false;
        }
      }
      return true;
    };//Spell Check Speaker Name function end

    function isCamelCase(str) {
      var regexp = /^[A-Z][a-z]*$/;
      return regexp.test(str)
    }

    //function to check same overlapping div
    function checkOverlappingDiv( segmentStart, segmentEnd) {
      console.trace(1);
      var overlapping = false;
      var sameSpeakerParams = {
        user_id,        
      }
      
      Object.keys(spectrum.regions.list).forEach(function (region) {
        var previousSpeakerStart = spectrum.regions.list[region].start;
        var previousSpeakerEnd = spectrum.regions.list[region].end;

        //|| (segmentStart == previousSpeakerStart && segmentEnd == previousSpeakerEnd)
        if ((segmentStart > previousSpeakerStart && segmentStart < previousSpeakerEnd) || //(segmentStart == previousSpeakerStart && segmentEnd == previousSpeakerEnd)||
          (segmentEnd > previousSpeakerStart && segmentEnd < previousSpeakerEnd) || (previousSpeakerStart > segmentStart && previousSpeakerStart < segmentEnd)) {
              overlapping=true;          
        }
      });
      return overlapping;
    }//Check OverLapping Div function End

    //function to renew annotation
function renew() {
  $('#annotation-type').val('default');
  $('#speaker-name').val('');
  $('#transcription-area').val('');
  document.getElementById('transcription-area').style.display = 'block';

  $('.form-inline').get(0).reset();
} //renew function end

    //function for promises and ajax request on submit
    function ajaxReq() {
      ////console.log("Hawa ");
      if (Object.keys(spectrum.regions.list).length == 0 || overallScore < 0) {
        overallScore = 100;
      } else {
        var promise = new Promise((resolve, reject) => {
          $.ajax({
            method: "POST",
            data: { audio_id: audio_id },
            url: "/get-reviews",
            async: false,
            success: function (actualResponse) {
              $.ajax({
                method: "POST",
                url: "/get-segments",
                data: {
                  user_id: user_id,
                  audio_id: audio_id
                },

                async: false,
                success: function (postResponse) {
                  actualResponseLength = actualResponse.length;

                  for (var i = 0; i < actualResponseLength; i++) {
                    var minStartValue = 0;
                    var minEndValue = 0;
                    var minDifference = 5;
                    var nearestStartSegment = 20;
                    var nearestStartSegment = 20;
                    var {
                      segment_id: actualsegmentId,
                      div_className: actualspeakerName,
                      div_title: actualannotationType,
                      segment_start: actualsegmentStart,
                      segment_end: actualsegmentEnd,
                      annotation_text: actualannotationText
                    } = actualResponse[i];
                    ////console.log(actualsegmentId + " " + i);
                    var color = "";
                    for (var j = 0; j < postResponse.length; j++) {
                      var {
                        segment_id: postssegmentId,
                        div_className: postsspeakerName,
                        div_title: postsannotationType,
                        segment_start: postssegmentStart,
                        segment_end: postssegmentEnd,
                        annotation_text: postsannotationText
                      } = postResponse[j];
                      //   var postssegmentId = postResponse[j]["segment_id"];
                      //   var postsspeakerName = postResponse[j]["div_className"];
                      //   var postsannotationType = postResponse[j]["div_title"];
                      //   var postssegmentStart = postResponse[j]["segment_start"];
                      //   var postssegmentEnd = postResponse[j]["segment_end"];
                      //   var postsannotationText = postResponse[j]["annotation_text"];
                      if (
                        Math.abs(actualsegmentStart - postssegmentStart) <
                        minDifference
                      ) {
                        minDifference = Math.abs(
                          actualsegmentStart - postssegmentStart
                        );
                        nearestStartSegment = Math.abs(
                          actualsegmentStart - postssegmentStart
                        );
                        nearestEndSegment = Math.abs(
                          actualsegmentStart - postssegmentStart
                        );
                        minStartValue = postssegmentStart;
                        minEndValue = postssegmentEnd;
                      }
                      if (
                        parseFloat(actualsegmentStart) -
                        parseFloat(postssegmentStart) <=
                        0.003 &&
                        parseFloat(actualsegmentStart) -
                        parseFloat(postssegmentStart) >=
                        0 &&
                        parseFloat(actualsegmentEnd) -
                        parseFloat(postssegmentEnd) <=
                        0.003 &&
                        parseFloat(actualsegmentEnd) -
                        parseFloat(postssegmentEnd) >=
                        0 &&
                        actualspeakerName == postsspeakerName &&
                        actualannotationType == "default"
                      ) {
                        //Correct Segment Created
                        correctSegmentCreated = true;
                        ////console.log("c" + parseFloat(actualsegmentStart));
                        ////console.log(actualspeakerName);
                        ////console.log(postsspeakerName);
                        break;
                      } else if (
                        parseFloat(actualsegmentStart) -
                        parseFloat(postssegmentStart) <=
                        0.005 &&
                        parseFloat(actualsegmentStart) -
                        parseFloat(postssegmentStart) >=
                        0 &&
                        parseFloat(actualsegmentEnd) -
                        parseFloat(postssegmentEnd) <=
                        0.005 &&
                        parseFloat(actualsegmentEnd) - parseFloat(minEndValue) >=
                        0 &&
                        actualspeakerName == postsspeakerName &&
                        actualannotationType != "default"
                      ) {
                        //Correct Segment Created
                        ////console.log(actualspeakerName);
                        ////console.log("c" + parseFloat(actualsegmentStart));
                        ////console.log(postsspeakerName);
                        correctSegmentCreated = true;
                        break;
                      } else {
                        if (
                          parseFloat(actualsegmentStart) -
                          parseFloat(postssegmentStart) <=
                          0.005 &&
                          parseFloat(actualsegmentStart) -
                          parseFloat(postssegmentStart) >=
                          0 &&
                          parseFloat(actualsegmentEnd) -
                          parseFloat(postssegmentEnd) <=
                          0.005 &&
                          parseFloat(actualsegmentEnd) -
                          parseFloat(postssegmentEnd) >=
                          0 &&
                          actualspeakerName != postsspeakerName &&
                          actualannotationType != "default"
                        ) {
                          overallScore += 1;
                          wrongAnnotationScore += 1;
                          ////console.log(                            "score Incorrect Annotation " + wrongAnnotationScore                          );
                          ////console.log(postsspeakerName);
                          ////console.log(actualspeakerName);
                        }
                        if (
                          parseFloat(actualsegmentStart) -
                          parseFloat(postssegmentStart) <=
                          0.005 &&
                          parseFloat(actualsegmentStart) -
                          parseFloat(postssegmentStart) >=
                          0 &&
                          parseFloat(actualsegmentEnd) -
                          parseFloat(postssegmentEnd) <=
                          0.005 &&
                          parseFloat(actualsegmentEnd) -
                          parseFloat(postssegmentEnd) >=
                          0 &&
                          actualspeakerName != postsspeakerName &&
                          actualannotationType == "default"
                        ) {
                          overallScore += 1;
                          wrongSpeakerScore += 1;
                          ////console.log(                            "score Speaker Incorrect " + wrongSpeakerScore
                          //);
                          ////console.log(postsspeakerName);
                          ////console.log(actualspeakerName);
                        }
                        //Incorrect Segement created
                        correctSegmentCreated = false;
                      }
                    }
                    ////console.log(correctSegmentCreated);
                    //creating Segments
                    spectrum.addRegion({
                      id: actualsegmentId + 100000,
                      start: actualsegmentStart,
                      end: actualsegmentEnd,
                      drag: false,
                      color: "rgba(0,0,0,0)"
                    });
                    //createDiv(divId,divClass,divTitle,segmentStart,segmentEnd,annotationText)
                    createTransperfectSegments(
                      actualsegmentId + 100000,                      
                      actualsegmentStart,
                      actualsegmentEnd,
                      "",
                      true
                    );
                  }
                  unnecessarySegmentsErrors +=
                    Math.abs(actualResponseLength - postsResponseLength) * 2;
                  overallScore = overallScore + unnecessarySegmentsErrors;
                  ////console.log("Total Score " + (100 - overallScore));
                  //Checking Pass or Fail
                  if (100 - overallScore > 60) {
                    passOrFail = "PASS";
                  } else {
                    passOrFail = "FAIL";
                  }
                  //Disallowing Clicking and Changing Values if the Submit request was successful
                  ////console.log("Submit Clicked");
                  disableAllInterfaceOnSubmit();
                  resolve();
                }
              });
            }
          });
        });
      }
    }//ajaxReq function end

    $("#select-display-training-segments").on("change",function(){
      displayCorrectSegment();
    });

  //Display Correct Training Segments 
    function displayCorrectSegment(){
      var selected=$("#select-display-training-segments").val();
      //console.log(selected);
      if(selected=="on"){
        $("#peaks-container").children().each(function (index, value) {
          if (this.getAttribute("actual") == "true") {
            $(this).show();
          }
          //console.log(this.getAttribute("actual"));
        });
      }else if(selected=="off"){
       $("#peaks-container").children().each(function (index, value) {
          if (this.getAttribute("actual") == "true" ) {
            $(this).hide();
          }
          //console.log(this.getAttribute("actual"));
        });
      }
    }


    //Function to store scores in database Users Table
    function saveScores() {      
      var todayDate = new Date();
      params = {
        user_id,
        audio_id: audio_id,
        wrongSpeakerScore,
        wrongAnnotationScore,
        unnecessarySegmentsErrors,
        overallScore: 100 - (overallScore),
        passOrFail,
        is_submitted: "TRUE"
      }
      $.ajax({
        method: "POST",
        url: "/save-test-score-on-users_audio_table",
        data: params,
        success: function () {
          ////console.log("Success");
        }
      })
    };//Save Scores Function End

    //Function to call on submit click
    $("#submit-button").on("click", function () {

      //submitClick();    
      ajaxReq();
      displayHamburger();
      saveScores();
      $("#submit-button").hide();
      $("#profile-link-button").show();
      logEvent("Audio Test Submitted - S");
      getWebAppId();
    });//Submit Button Click Function End

    function getWebAppId() {
      $.ajax({
        method: "POST",
        url: "/get-web-app-id",
        data: {
          user_id: user_id
        },
        success: function (data) {

          var mailParams = {
            "user_id": `${data[0].web_app_id}`,
            "status": "3",
            "project_type_id": "4"
          }
          $.ajax({
            method: "POST",
            url: "{{ webapp_basepath }}/api/set-user-language-project-type-status",
            data: mailParams,
            success: function () {
              //console.log("Web app status set");
            }
          });
        }
      });
    }

    //function to display current div content in annotation box
    function displayCurrentContents() {
       
      if (spectrum.regions.getCurrentRegion() != null && !updateAnnotationOnChange && !updateAnnotationOnClick && !updateTopDivSpeaker && !updateTopDivSpeakerOnClick) {
        $("#top-div-speaker-control").hide();
        $("#annotation-box").show();
        var segmentId = spectrum.regions.getCurrentRegion().id;
        
        if(segmentId!=currentId){
          //Add Markers after clearing previous markers
          spectrum.markers.clear();
         
        currentId = spectrum.regions.getCurrentRegion().id;

        //highlight current region
        highlightRegion();

        //segment start variables
        var startMinute = secondsToMinutes(spectrum.regions.getCurrentRegion().start);
        var startSeconds = secondsToSeconds(spectrum.regions.getCurrentRegion().start);
        var startMilliseconds = secondsToMilliseconds(spectrum.regions.getCurrentRegion().start);
        currentStartTime = spectrum.regions.getCurrentRegion().start

        //segment end variables
        var endMinute = secondsToMinutes(spectrum.regions.getCurrentRegion().end);
        var endSeconds = secondsToSeconds(spectrum.regions.getCurrentRegion().end);
        var endMilliseconds = secondsToMilliseconds(spectrum.regions.getCurrentRegion().end);
        currentEndTime = spectrum.regions.getCurrentRegion().end;

        //displaying texts   
        $("#annotation-start-minute").val(startMinute);
        $("#annotation-start-seconds").val(startSeconds);
        $("#annotation-start-milliseconds").val(startMilliseconds);
        $("#annotation-end-minute").val(endMinute);
        $("#annotation-end-seconds").val(endSeconds);
        $("#annotation-end-milliseconds").val(endMilliseconds);

        
      

        //($("#peaks-container").children().is(`#${segmentId}`) > 0)
        if ($("#peaks-container").children().is(`#${segmentId}`) > 0) {          
          
          var divColor = document.getElementById(segmentId).style.background;

          //changing color of Annotation Heading
          $(".annotation-editHeading").css("backgroundColor", divColor);
            setTransperfectFields(currentId);
            //Wake word start marker                
            const wordStart=parseAnnotationTime($("#wake-word-start-minute").val(),$("#wake-word-start-seconds").val(),$("#wake-word-start-milliseconds").val());
            addMarker(spectrum,wordStart,'WS','#ff990a');

            //Wake word end marker
            const wordEnd=parseAnnotationTime($("#wake-word-end-minute").val(),$("#wake-word-end-seconds").val(),$("#wake-word-end-milliseconds").val());
            addMarker(spectrum,wordEnd,'WE','#00ffcc');

            //Command start marker
            const commandStart=parseAnnotationTime($("#command-start-minute").val(),$("#command-start-seconds").val(),$("#command-start-milliseconds").val());
            addMarker(spectrum,commandStart,'CS','#eb4034');

            //Start of assistant marker
            const assistantStart=parseAnnotationTime($("#start-of-assistant-minute").val(),$("#start-of-assistant-seconds").val(),$("#start-of-assistant-milliseconds").val());
            addMarker(spectrum,assistantStart,'SOA','#a71dbf');
                                
            }
        }        
      }
    }//DisplayCurrentContents function end

    function addMarker(spectrum, time, label, color) {
     
      if (time && time > 0) {
        spectrum.markers.add({
          time: time,
          label,
          color,
          position: 'top',
        });
      }
    }

</script>    
</body>
</html>